<html>
<meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1, user-scalable=0"/>
<script src="spine-canvas.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
<script src="https://code.jquery.com/jquery-3.1.0.min.js"></script>

<script src="assets/assets.js"></script>

<script>
window.requestInterval = function(fn, delay) {
	if( !window.requestAnimationFrame       &&
		!window.webkitRequestAnimationFrame &&
		!(window.mozRequestAnimationFrame && window.mozCancelRequestAnimationFrame) && // Firefox 5 ships without cancel support
		!window.oRequestAnimationFrame      &&
		!window.msRequestAnimationFrame)
			return window.setInterval(fn, delay);

	var start = new Date().getTime(),
		handle = new Object();

	function loop() {
		var current = new Date().getTime(),
			delta = current - start;

		if(delta >= delay) {
			fn.call();
			start = new Date().getTime();
		}

		handle.value = requestAnimFrame(loop);
	};

	handle.value = requestAnimFrame(loop);
	return handle;
}

/**
 * Behaves the same as clearInterval except uses cancelRequestAnimationFrame() where possible for better performance
 * @param {int|object} fn The callback function
 */
    window.clearRequestInterval = function(handle) {
    window.cancelAnimationFrame ? window.cancelAnimationFrame(handle.value) :
    window.webkitCancelAnimationFrame ? window.webkitCancelAnimationFrame(handle.value) :
    window.webkitCancelRequestAnimationFrame ? window.webkitCancelRequestAnimationFrame(handle.value) : /* Support for legacy API */
    window.mozCancelRequestAnimationFrame ? window.mozCancelRequestAnimationFrame(handle.value) :
    window.oCancelRequestAnimationFrame	? window.oCancelRequestAnimationFrame(handle.value) :
    window.msCancelRequestAnimationFrame ? window.msCancelRequestAnimationFrame(handle.value) :
    clearInterval(handle);
};
window.requestTimeout = function(fn, delay) {
	if( !window.requestAnimationFrame      	&&
		!window.webkitRequestAnimationFrame &&
		!(window.mozRequestAnimationFrame && window.mozCancelRequestAnimationFrame) && // Firefox 5 ships without cancel support
		!window.oRequestAnimationFrame      &&
		!window.msRequestAnimationFrame)
			return window.setTimeout(fn, delay);

	var start = new Date().getTime(),
		handle = new Object();

	function loop(){
		var current = new Date().getTime(),
			delta = current - start;

		delta >= delay ? fn.call() : handle.value = requestAnimFrame(loop);
	};

	handle.value = requestAnimFrame(loop);
	return handle;
};

/**
 * Behaves the same as clearTimeout except uses cancelRequestAnimationFrame() where possible for better performance
 * @param {int|object} fn The callback function
 */
window.clearRequestTimeout = function(handle) {
    window.cancelAnimationFrame ? window.cancelAnimationFrame(handle.value) :
    window.webkitCancelAnimationFrame ? window.webkitCancelAnimationFrame(handle.value) :
    window.webkitCancelRequestAnimationFrame ? window.webkitCancelRequestAnimationFrame(handle.value) : /* Support for legacy API */
    window.mozCancelRequestAnimationFrame ? window.mozCancelRequestAnimationFrame(handle.value) :
    window.oCancelRequestAnimationFrame	? window.oCancelRequestAnimationFrame(handle.value) :
    window.msCancelRequestAnimationFrame ? window.msCancelRequestAnimationFrame(handle.value) :
    clearTimeout(handle);
};


$.fn.extend({
  animateCss: function(animationName, callback) {
    var animationEnd = (function(el) {
      var animations = {
        animation: 'animationend',
        OAnimation: 'oAnimationEnd',
        MozAnimation: 'mozAnimationEnd',
        WebkitAnimation: 'webkitAnimationEnd',
      };

      for (var t in animations) {
        if (el.style[t] !== undefined) {
          return animations[t];
        }
      }
    })(document.createElement('div'));

    this.addClass('animated ' + animationName).one(animationEnd, function() {
      $(this).removeClass('animated ' + animationName);

      if (typeof callback === 'function') callback();
    });

    return this;
  },
});
</script>
<style>

@media screen and (min-device-width: 422px) {
canvas {
	width:542px !important;
	     position: relative !important;
	margin-left: auto;
		right: 0;
	margin-right: auto;
	display: block;
margin: 0 auto;
}
.uiWrapper{
	width:542px !important;
			 position: relative !important;
	margin-left: auto;
		right: 0;
	margin-right: auto;
	display: block;
margin: 0 auto;
}
#bgimg {
	     width:422px;
			 margin-left: auto;
			   right: 0;
			 margin-right: auto;
			 display: block;
    margin: 0 auto;
}
.textbox{
	margin-left: 14%;
}

}

	* { margin: 0; padding: 0; }
	body, html { height: 100% ; overflow: hidden;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;
  }

	canvas { position: absolute; width: 100% ;height: 100%;
    background-image:"transparent"
    background-repeat: no-repeat;
        background-size: 414 736px;
       background-attachment: fixed;
  }
	.option{

		height:60px;
    position: relative;
    top:40px;
    background-position: center;
		 background-image: url("assets/textbox.png");
		 background-repeat: no-repeat;
			background-size: contain;
			color:white;
      line-height: 50px;
			font-size: 20px;

	}
    .flip2::before {
     transform: scaleX(-1);
    }
  	.textbox::before{
      background-position: left center ;
      background-image: url("assets/textbox2.png");
      background-repeat: no-repeat;
       background-size: contain;
       max-width: 460px;

       content: "";
       width:100%;
        padding-left: 15px;
        padding-right: 15px;
        position: absolute;
        order:2;
        height: 232px;
        top: -100px;
        left:-15px;
        z-index: -1;

    }
	.textbox {
    order:1;
		  min-width: 230px;
		max-width: 400px;
  z-index: 999;
		position: absolute;
      flex-direction: row-reverse;
		width:60%;
    padding-left: 15px;
		height: 47px;
    padding-right: 15px;
    top:60%;
    left:15%;
    display: flex;
    line-height: 24px;
 align-items: center;
 justify-content: center;


		  text-align: center;

		 font-size: 20px;
	}

	.uiWrapper
	{
		height: 100%;
		width: 100%;
	}
	.optionWrapper
	{
		position: absolute;
		width:100%;
    height: 100px;
    bottom:80px;
    text-align: center;
	}
  .cta
  {
    width:100%;
		 top: 0;
    height: 100%;
    position: absolute;
    background-image: url("assets/cta.jpg");
    display: none;
    background-position:  center ;
    background-repeat: no-repeat;
    background-size: cover;
    z-index: 9999
  }
  .handCursor{

  }
  .tap {
    text-align: center;
    color: white;
    font-size:30px;
    position:absolute;
    bottom:20px;
    width: 100%;
		left:30%;
  }
 #bgimg {
   width:200%; /* you can use % */
    height: auto;
     background-size:contain;
     position: absolute;
     bottom: 0px;
     z-index: -1;
 }
</style>

<body style='overflow:hidden'>
  <div style='background-color:white;height:100%;width:100%;display: flex;align-items: center;justify-content: center;z-index:999999;overflow:hidden'
  id='loading'>
    <img src="assets/loading_icon.gif" style=' max-width: 50%;' />
  </div>

<div id='mainGame' style='display:none'>
<canvas id="canvas"></canvas>
<div id='uiWrapper'>
  <div  class="textbox">

  </div>
  <div class='optionWrapper'>

    <div class="option option1 animated infinite pulse">
	Ask mom for advice
</div>
<div class="option option2 animated infinite pulse">
		Call your boyfriend
</div>
</div>
</div>

<div class='cta'> </div>
<div  class='tap'>
  <div class='handCursor animated infinite jello'>Tap!</div>
  <img src='assets/Hand_Cursor.svg' class='handCursor animated infinite pulse	' width='100'/>
</div>

  <img src='assets/Rae.png'  id='assetsRaepng' style="display:none"/>
  <img src='assets/Ivy_2.png'  id='assetsIvy_2png'style="display:none"/>
  <img  id='bgimg' src="assets/bg_portrait.jpg" />
</div>

</div>
</body>
<script>

"use strict";

var lastFrameTime = Date.now() / 1000;
var canvas, context;
var assetManager;
var skeleton, state, bounds;
var skeleton2, state2, bounds2;
var skeletonRenderer;
var animName2 = "aa_yell";
var skelName = "Ivy_2";
var animName = "1_start";
var option_1 = "Ask mom for advice";
var option_2 = "Call your boyfriend";
var display_text = true;
var momdraw = false;
var inCTA = false;
var scale = 1;
var vx = 0;
var vy = 0;
var scaleTo = 1;
var newvx = 0;
var newvy = 0;
var newScale=0.7;
var atlas=[];
var atlas2={};
function init() {
	$('.tap').show();
	newScale = 0.7;
	canvas = document.getElementById("canvas");
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
	context = canvas.getContext("2d");

	skeletonRenderer = new spine.canvas.SkeletonRenderer(context);
	// enable debug rendering
	skeletonRenderer.debugRendering = false;
	// enable the triangle renderer, supports meshes, but may produce artifacts in some browsers
	skeletonRenderer.triangleRendering = false;

	assetManager = new spine.canvas.AssetManager();
	var files = [];
	assetManager.loadText = function (path) {
		assetManager.assets[path] = assets.assets[path];
	};

	assetManager.loadTexture = function (path) {

		assetManager.assets[path] = new spine.canvas.CanvasTexture(document.getElementById(path.replace(/\./g, '').replace(/\//g, '')));
	};

	assetManager.loadText("assets/" + skelName + ".json");
	assetManager.loadText("assets/" + skelName.replace("-pro", "").replace("-ess", "") + ".atlas");
	assetManager.loadTexture("assets/" + skelName.replace("-pro", "").replace("-ess", "") + ".png");

	assetManager.loadText("assets/" + "Rae" + ".json");
	assetManager.loadText("assets/" + "Rae" + ".atlas");

	assetManager.loadTexture("assets/" + "Rae" + ".png");

	requestAnimationFrame(load);
}
var mytim;
function script(scripts) {
	clearTimeout(mytim);

	$('.textbox').animateCss('bounceIn', 'fast');
	console.log(scripts[0][0]);

	$('.textbox').html(scripts[0][0]);

	//  typeWriter(".textbox","true",40);
	if (scripts[0][1] == 0) {
		$('.textbox').css('left', '27%');
		$('.textbox').removeClass('flip2');
	} else if (scripts[0][1] == 1) {
		$('.textbox').addClass('flip2');
		$('.textbox').css('left', '11%');
	}
	scripts.splice(0, 1);
	clearTimeout(mytim);
	scripts.forEach(function (script, i) {
		mytim = setTimeout(function () {
			clearTimeout(mytim);
			if (script[1] == 0) {
				$('.textbox').removeClass('flip2');c

				$('.textbox').css('left', '27%');
			} else if (scripts[0][1] == 1) {

				$('.textbox').addClass('flip2');

				$('.textbox').css('left', '11%');
				//      $('.textbox').animateCss('flipOutY');

			}
			$('.textbox').animateCss('bounceIn', 'fast');
			$('.textbox').html(script[0]);
			//    typeWriter(".textbox","true",40);
		}, 2100 * (i + 1));
	});
}
script([["Oh no! It's positive!", 0]]);
function load() {
	if (assetManager.isLoadingComplete()) {

		var data = loadSkeleton(skelName, animName, "default");
		skeleton = data.skeleton;
		state = data.state;
		bounds = data.bounds;

		skeleton2 = data.skeleton2;
		state2 = data.state2;
		bounds2 = data.bounds2;
		requestAnimationFrame(render);
		$('#loading').fadeOut();
		$('#mainGame').fadeIn();
	} else {
		requestAnimationFrame(load);
	}
}
function cta() {
	$('.tap').fadeOut();
	$('.cta').show();
	$('.cta').animateCss('flipInY');
	inCTA = true;
}
function loadSkeleton(name, initialAnimation, skin) {
	if (skin === undefined) skin = "default";

	// Load the texture atlas using name.atlas and name.png from the AssetManager.
	// The function passed to TextureAtlas is used to resolve relative paths.
	atlas = new spine.TextureAtlas(assetManager.get("assets/" + name.replace("-pro", "").replace("-ess", "") + ".atlas"), function (path) {
		return assetManager.get("assets/" + path);
	});
	atlas2 = new spine.TextureAtlas(assetManager.get("assets/" + "Rae" + ".atlas"), function (path) {
		return assetManager.get("assets/" + path);
	});
	// Create a AtlasAttachmentLoader, which is specific to the WebGL backend.
	var atlasLoader = new spine.AtlasAttachmentLoader(atlas);
	var atlasLoader2 = new spine.AtlasAttachmentLoader(atlas2);
	// Create a SkeletonJson instance for parsing the .json file.
	var skeletonJson = new spine.SkeletonJson(atlasLoader);
	var skeletonJson2 = new spine.SkeletonJson(atlasLoader2);
	// Set the scale to apply during parsing, parse the file, and create a new skeleton.
	var skeletonData = skeletonJson.readSkeletonData(assetManager.get("assets/" + name + ".json"));
	var skeletonData2 = skeletonJson2.readSkeletonData(assetManager.get("assets/" + "Rae" + ".json"));

	var skeleton = new spine.Skeleton(skeletonData);
	var skeleton2 = new spine.Skeleton(skeletonData2);
	skeleton.flipY = true;
	skeleton2.flipY = true;
	var bounds = calculateBounds(skeleton);
	var bounds2 = calculateBounds(skeleton2);
	skeleton.setSkinByName(skin);
	skeleton2.setSkinByName(skin);
	// Create an AnimationState, and set the initial animation in looping mode.
	var animationState = new spine.AnimationState(new spine.AnimationStateData(skeleton.data));
	var animationState2 = new spine.AnimationState(new spine.AnimationStateData(skeleton2.data));
	animationState.setAnimation(0, animName, true);

	animationState2.setAnimation(0, "wait", true);
	animationState2.addListener({
		event: function event(trackIndex, _event) {},
		complete: function complete(trackIndex, loopCount) {
			if (animName2 == "enter") {
				animName2 = "aa_tell_wait";
				animationState2.setAnimation(0, "aa_tell_wait", false);
			}
			if (animName2 == "aa_angry") {
				animName2 = "aa_tell_wait";
				animationState2.setAnimation(0, "aa_tell_wait", false);
			}
			if (animName2 == "aa_tell_wait") {
				animName2 = "aa_angry_shake";
				animationState2.setAnimation(0, "aa_angry_shake", true);
			}
		},
		start: function start(trackIndex) {},
		end: function end(trackIndex) {}
	});

	animationState.addListener({
		event: function event(trackIndex, _event2) {

			// console.log("Event on track " + trackIndex + ": " + JSON.stringify(event));
		},
		complete: function complete(trackIndex, loopCount) {

			if (animName == "a_call") {
				animName = "a_wait";
				animationState.setAnimation(0, animName, false);
			}
			if (animName == "a_wait") {
				animName = "a_question";
				animationState.setAnimation(0, animName, false);
			}
			if (animName == "a_question") {
				animName = "a_wait_loop";
				animationState.setAnimation(0, "a_wait", true);
				display_text = true;
				$('.option').fadeIn("fast");
				option_1 = "Tell her everything";
				option_2 = "Don't disappoint her";
			}

			if (animName == "aa_tell") {
				animName = "aa_tell_loop";
				animationState.setAnimation(0, animName, true);
				animationState2.setAnimation(0, animName2, false);
			}

			if (animName == "b_phone_dial") {
				animName = "b_phone_loop";
				animationState.setAnimation(0, animName, true);
				display_text = true;
				$('.option').fadeIn("fast");

				option_1 = "Tell him he's a father";
				option_2 = "Ask him if you can meet up";
			}

			if (animName == "ba_hang_up") {
				animName = "ba_end";
				animationState.setAnimation(0, animName, true);
			}
			if (animName == "ba_end") {
				cta();
				animName = "end";
			}
			if (animName == "bb_phone_cry_start") {
				animName = "bb_phone_cry";
				animationState.setAnimation(0, animName, true);
			}

			if (animName == "bb_phone_cry") {
				setTimeout(function () {
					cta();
				}, 1000);

				animName = "end";
			}

			if (animName == "aa_run_out") {
				setTimeout(function () {
					cta();
				}, 1000);
				animName = "endno";
			}

			if (animName == "ab_question") {
				animName = "ab_wait";
				animationState.setAnimation(0, "a_wait", false);
			}

			if (animName == "ab_sad_start") {
				animName = "ab_sad_start";
				animationState.setAnimation(0, "ab_sad", true);
			}
			$(".option1").html(option_1);
			$(".option2").html(option_2);

			if (display_text) {
				$('.option_1').show();
				$('.option_2').show();
			} else {
				$('.option_1').hide();
				$('.option_2').hide();
			}
			// console.log("Animation on track " + trackIndex + " completed, loop count: " + loopCount);
		},
		start: function start(trackIndex) {
			// console.log("Animation on track " + trackIndex + " started");
		},
		end: function end(trackIndex) {
			// console.log("Animation on track " + trackIndex + " ended");
		}
	});
  var fixed = document.getElementById('mainGame');

fixed.addEventListener('touchmove', function(e) {

        e.preventDefault();

}, false);
 var clickf= function (evt) {
	 if(!evt.clientY)evt.clientY=e.touches[0].evt.clientY
	 console.log(evt,evt.clientY / canvas.height)
   if (inCTA) {
     FbPlayableAd.onCTAClick();
   }
   display_text = false;

   if (animName == "1_start") {

     if (evt.clientY / canvas.height < 0.88) {
			  	 console.log("1",evt.clientY / canvas.height)
       animName = "a_call";
       animationState.setAnimation(0, animName, false);

       script([["MOOOM!", 0], ["Yes, dear?", 1]]
       //   ["Mom I have to tell you something!",0],
       //   ["What does my princess want?",1]
       );
       momdraw = true;

       animationState2.setAnimation(0, "enter", false);
     } else {
			 	 console.log("2",evt.clientY / canvas.height)
       animName = "b_phone_dial";
       animationState.setAnimation(0, animName, false);
       script([["Mark I have to tell you something!", 0], ["Can I call you later, I'm in a middle of something?", 1]]);
     }
     newScale = 0.67;
     newvx -= 18;
   }

   if (animName == "b_phone_loop") {
     if (evt.clientY / canvas.height < 0.88) {
       script([["WHAT?! NO, THIS ISN'T HAPPENING!", 1]]
       //   ["MARK?! He hates me now! What am I going to do...",0]

       );

       animName = "ba_hang_up";
       animationState.setAnimation(0, animName, false);
     } else {
       script([["I can't do this anymore, I love someone else!", 1]]);

       setTimeout(function () {
         script([
           //      ["WHAT?",0] ,  ["But...",0]
         ]);
       }, 3200);
       animName = "bb_phone_cry_start";
       animationState.setAnimation(0, animName, false);
     }
   }

   if (animName == "aa_tell_loop") {
     // script([ ["Wait! Veronica! We can still fix this!",1] ])


     animName = "aa_run_out";
     animationState.setAnimation(0, animName, false);
   }
   if (animName == "a_wait_loop") {
     if (evt.clientY / canvas.height < 0.88) {
       animName = "aa_tell";
       script([["What?! What were you thinking?!", 1]]);
       animName = "aa_run_out";
       animationState2.setAnimation(0, animName2, false);
       setTimeout(function () {
         animationState.setAnimation(0, animName, false);
       }, 1000);

       //	 animationState.setAnimation(0, "aa_tell", false);
     } else {
       script([["Mom can you please get me a glass of water?", 0], ["What am I gonna do now?", 0]]);

       setTimeout(function () {
         animName = "ab_sad_start";
         animationState.setAnimation(0, animName, false);
       }, 2000);
       setTimeout(function () {
         cta();
       }, 5000);

       animationState2.setAnimation(0, "ab_smile", false);
     }
   }

   if (animName == "ab_wait") {
     animName = "ab_sad_start";
     //cta();

     animationState.setAnimation(0, animName, false);
   }

   if (animName == "ba_end" || animName == "bb_phone_cry" || animName == "ab_sad") {
     //();
   }
   $('.option').fadeOut("fast");
	 	$('.tap').fadeOut("fast");
 }
	document.addEventListener('click',clickf, false);
  	document.addEventListener('touchend',clickf, false);
	// Pack everything up and return to caller.
	return { skeleton: skeleton, state: animationState, bounds: bounds,
		skeleton2: skeleton2, state2: animationState2, bounds2: bounds2
	};
}

function calculateBounds(skeleton) {
	var data = skeleton.data;
	skeleton.setToSetupPose();
	skeleton.updateWorldTransform();
	var offset = new spine.Vector2();
	var size = new spine.Vector2();
	skeleton.getBounds(offset, size, []);
	return { offset: offset, size: size };
}

function render() {
	var now = Date.now() / 1000;
	var delta = now - lastFrameTime;
	lastFrameTime = now;

	var bgpy = vy;
	var bgscale = scale * 2;
	scale += (newScale - scale) * 0.04;
	vx += (newvx - vx) * 0.04;
	vy += (newvy - vy) * 0.04;


	if(canvas.clientWidth > 422){
			$('#bgimg').css('width', '542px');
			$('#bgimg').css('left', "0");
					scale=newScale = 0.67;
	}else {

			$('#bgimg').css('width', bgscale * 100 + '%');
			$('#bgimg').css('left', vx / bgscale + "px");
	}
	resize();
	context.save();
	context.setTransform(1, 0, 0, 1, 0, 0);
	context.fillStyle = "#cccccc";
	context.clearRect(0, 0, canvas.width, canvas.height);
	context.restore();

	context.save();
	context.scale(scale, scale);
	context.translate(vx * 30, vy * 30);
	state.update(delta);
	state.apply(skeleton);

	state2.update(delta);
	state2.apply(skeleton2);
	skeleton.updateWorldTransform();
	skeletonRenderer.draw(skeleton);
	skeleton2.updateWorldTransform();
	context.translate(1150, 0);
	if (momdraw) skeletonRenderer.draw(skeleton2);
	context.restore();
	context.font = "200px Arial";
	if (display_text) {}

	//	context.fillText(option_1,canvas.width / 2,-400);
	//	context.fillText(option_2,canvas.width / 2,0);


	//	context.strokeStyle = "green";
	//	context.beginPath();
	//	context.moveTo(-1000, 0);
	//	context.lineTo(1000, 0);
	//	context.moveTo(0, -1000);
	//	context.lineTo(0, 1000);
	//	context.stroke();

	requestAnimationFrame(render);
}

function resize() {
	var w = canvas.clientWidth;
	var h = canvas.clientHeight;
	if (canvas.width != w || canvas.height != h) {
		canvas.width = w;
		canvas.height = h;
	}

	// magic
	var centerX = bounds.offset.x + bounds.size.x / 2;
	var centerY = bounds.offset.y + bounds.size.y / 2;
	var scaleX = bounds.size.x / canvas.width;
	var scaleY = bounds.size.y / canvas.height;
	var scale = 4;

	if (scale < 1) scale = 1;
	var width = canvas.width * scale;
	var height = canvas.height * scale;

	context.setTransform(1, 0, 0, 1, 0, 0);
	context.scale(1 / scale, 1 / scale);

	context.translate(-centerX, -centerY);
	context.translate(width / 2, height / 2);
}

(function () {
	init();
})();

</script>
</html>
